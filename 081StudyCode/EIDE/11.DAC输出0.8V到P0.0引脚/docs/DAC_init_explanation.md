# LKS32MC081C8T8 ―― DAC_init 函数逐行白话解析

> 目标：让完全没有底层经验的同学，也能读懂下列 C 代码在做什么、为什么要这样写。

源码片段（来自 `AppFunction/hardware_init.c`）
```c
void DAC_init(void)
{
    SYS_AnalogModuleClockCmd(SYS_AnalogModule_DAC, ENABLE);
    SYS_WR_PROTECT = 0x7a83;

    SYS_AFE_REG1 &= ~((u32)0x03 << 6);
    SYS_AFE_REG1 |= (DAC_RANGE_1V2 << 6);

    if (((SYS_AFE_REG1 >> 6) & 0x03) == DAC_RANGE_1V2) {
        SYS_AFE_DAC_DC  = Read_Trim(0x00000344);
        SYS_AFE_DAC_AMC = Read_Trim(0x00000334);
    } else if (((SYS_AFE_REG1 >> 6) & 0x03) == DAC_RANGE_3V0) {
        SYS_AFE_DAC_DC  = Read_Trim(0x00000340);
        SYS_AFE_DAC_AMC = Read_Trim(0x00000330);
    } else if (((SYS_AFE_REG1 >> 6) & 0x03) == DAC_RANGE_4V85) {
        SYS_AFE_DAC_DC  = Read_Trim(0x00000348);
        SYS_AFE_DAC_AMC = Read_Trim(0x00000338);
    }

    SYS_AFE_REG3 |= BIT11;           /* 让 DAC 模拟电压走到 P0.0 引脚 */
    SYS_AFE_DAC   = 2048;            /* 输出 0.6 V（在 1.2 V 满量程下） */
    SYS_WR_PROTECT = 0x0;
}
```

---
## 预备知识：寄存器、位掩码、位运算

| 概念 | 通俗解释 |
|------|----------|
| **寄存器 (Register)** | MCU 内部的一个 32 位/16 位小存储格，用来控制硬件模块。你可以像给普通变量赋值那样读/写寄存器。 |
| **位 (bit)** | 每个寄存器有很多"开关"（0 或 1）。不同的开关控制不同功能。|
| **位掩码 (Bit-mask)** | 一个值里只有某些位是 1，用来"选中"或"修改"那几位。`BIT11` 就是只选中第 11 位的掩码。|
| **按位运算符** | `&`(AND)、`|`(OR)、`~`(NOT)、`<<`(左移)、`>>`(右移)。它们按 **二进制** 一位一位地计算。|

> 关键套路：
> * **清零某几位**：用 `& 反掩码`（掩码位是 0，其余是 1）。
> * **置 1 某几位**：用 `| 掩码`（想置 1 的位写 1，其余写 0）。


## 逐行详解

### 1. 打开 DAC 时钟
```c
SYS_AnalogModuleClockCmd(SYS_AnalogModule_DAC, ENABLE);
```
- MCU 里的 **时钟门控** 功能：关掉不用的模块可以省电，也防止误操作。
- 这行就是"给 DAC 模块供电/供时钟"。否则后面改寄存器也没效果。

### 2. 解锁系统寄存器
```c
SYS_WR_PROTECT = 0x7a83;
```
- 芯片怕你误改关键寄存器，默认上锁。
- 写入固定钥匙 `0x7A83` ? 接下来几行可以修改 `SYS_AFE_*` 寄存器。

### 3. **重点**：`SYS_AFE_REG1 &= ~((u32)0x03 << 6);`
这一行常让新手迷惑。下面拆到最底层：

1. **`0x03`** ：十六进制 `03` = 二进制 `0000 0011`，只有低两位是 1。
2. **`(u32)0x03`** ：告诉编译器当成 32 位无符号整数来算（防止溢出警告）。
3. **`<< 6`** ：左移 6 位 → `0000 0011` 变 `1100 0000` (0xC0)。现在第 6、7 位是 1。
4. **`~`** ：按位取反 → `…1111 0011 1111`（32 位里只有 6、7 位是 0）。这就是"反掩码"。
5. **`&=`** ：把左侧变量与反掩码做 AND 再写回。
   - AND 的规则：`1&x = x`，`0&x = 0`。
   - 因为反掩码里只有位 6、7 是 0，所以**只有这两位被清零**，其他 30 位保持不变。

> **目的**：把寄存器 `SYS_AFE_REG1` 第 6、7 位清零，为下面重新写入量程做准备。

### 4. 选择 DAC 量程 1.2 V
```c
SYS_AFE_REG1 |= (DAC_RANGE_1V2 << 6);
```
- `DAC_RANGE_1V2` 宏值 = 1。
- 左移 6 位 → 在位 7:6 写入二进制 `01`。
- 手册：`00=3 V`，`01=1.2 V`，`10=4.85 V`。

### 5. 根据量程加载出厂校准值
```c
if (((SYS_AFE_REG1 >> 6) & 0x03) == DAC_RANGE_1V2) { … }
```
- `>> 6` 右移 6 位，把位 7:6 移到最低位。
- `& 0x03` 只保留这两位。
- 判断量程并从 **NVR** 里 `Read_Trim()` 读出对应的 **直流偏移/DC** 和 **增益/幅度** 校准值。

这句 if 其实就想做一件事：**判断"量程位"到底设成了哪种量程**。下面一句句拆：

| 步骤 | 具体操作 | 结果（举例：寄存器位 7:6 = `01`） |
|------|-----------|---------------------------------------|
|① `SYS_AFE_REG1 >> 6` | 把整寄存器右移 6 位 | 原来的位 7,6 被挪到最低两位（现在变成 `0b01`） |
|② `… & 0x03` | 用 `0x03` (`0b11`) 做 AND，只留下最低两位 | 仍是 `0b01`，其余位被清 0 |
|③ `== DAC_RANGE_1V2` | 拿结果去跟常量 `DAC_RANGE_1V2`（值就是 `1` 或 `0b01`）比较 | 相等 → 量程是 **1.2 V**；不等 → 去判断下一种量程 |

如果判定为 1.2 V，就执行大括号里的代码：
```c
SYS_AFE_DAC_DC  = Read_Trim(0x00000344);  // 直流(DC)校正值
SYS_AFE_DAC_AMC = Read_Trim(0x00000334);  // 增益(幅度)校正值
```
它们从 **NVR**（一块只读存储区）里取出厂家在出厂时测好的校准数字，让 DAC 输出更精准。

#### ? 补充：这些地址是怎么来的？为什么写入这两个寄存器？

* **NVR 校准表** ― 数据手册附录列出 DAC 不同量程对应的偏移/增益地址：

  | 量程 | 偏移 (DC) 地址 | 增益 (AMC) 地址 |
  |------|---------------|-----------------|
  | 3.0 V | `0x00000340` | `0x00000330` |
  | 1.2 V | `0x00000344` | `0x00000334` |
  | 4.85 V| `0x00000348` | `0x00000338` |

* `Read_Trim(addr)` 会：
  1. 把 `addr` 写进 NVR 地址寄存器；
  2. 触发一次 NVR 读取；
  3. 返回读出的 32-bit 数据。
  你只需把"手册给的地址"喂进去即可。

* 读取完后把值写进：
  - **`SYS_AFE_DAC_DC`** → 直流偏移(Offset)补偿寄存器。
  - **`SYS_AFE_DAC_AMC`** → 增益(Amplitude)补偿寄存器。

  硬件启动后会自动用这两个补偿值把 DAC 输出曲线"拉直"，确保 0 码真的是 0 V，满量程也不超差。

### 6. 打开 DAC→P0.0 模拟开关
```c
SYS_AFE_REG3 |= BIT11;
```
- `BIT11` = `0x0800`，只选中第 11 位。
- 在 `SYS_AFE_REG3` 里，第 11 位被手册定义为 `DAC_OUT_EN`：1=让 DAC 输出连到 P0.0。

### 7. 设定输出码，得到 0.6 V
```c
SYS_AFE_DAC = 2048;  /* 0x0800 */
```
- DAC 是 12 bit，范围 0~4095。
- Vout = 码值 / 4096 × 满量程；满量程 1.2 V ? `2048/4096 × 1.2 ≈ 0.6 V`。

### 8. 再次上锁
```c
SYS_WR_PROTECT = 0x0;
```
- 清零写保护寄存器 ? 关键寄存器重新只读。

---
## 小结（一句话版）
> 先开时钟→解锁→清量程位→选 1.2 V→加载校准→连到 P0.0→写 2048 →上锁。执行后，P0.0 引脚输出约 0.6 V 的模拟电压。

---
## 延伸阅读
1. 《LKS32MC08x 技术参考手册》章节：SYS_AFE、DAC。  
2. 位运算快速记忆：
   - 清零：`var &= ~mask;`  
   - 置 1：`var |=  mask;`  
   - 取值：`value = (var >> n) & bitmask;`  
3. 十六进制与二进制转换：一位十六进制 = 四位二进制。

> 学习小贴士：
> * 把寄存器位图打印出来，与代码同时看，效果最好。
> * 亲手改动量程、码值后，用万用表测 P0.0 电压验证，加深理解。 